# StreamXBar

## Описание проекта

**StreamXBar** — это модуль на Verilog, реализующий потоковый кроссбар для коммутации `S_DATA_COUNT` master-устройств и `M_DATA_COUNT` slave-устройств с арбитражем по политике Round-Robin. Основная задача модуля — обеспечить передачу данных от master-устройств к slave-устройствам с минимальными задержками и без блокировок, если запросы направлены к различным slave-устройствам. В случае, если несколько master-устройств пытаются обратиться к одному и тому же slave-устройству, используется механизм арбитража Round-Robin для справедливого распределения приоритетов между master-устройствами.

### Основные возможности:

- Коммутация до `S_DATA_COUNT` master-устройств с `M_DATA_COUNT` slave-устройствами.
- Поддержка параллельной передачи данных при отсутствии конфликтов.
- Арбитраж запросов по алгоритму Round-Robin в случае конфликтов.
- Потранзакционный арбитраж: переключение арбитра происходит только после завершения текущей транзакции или при превышении передачи пакетов.
- Выходной сигнал `m_id_o` сообщает номер входного потока, с которого поступила выходная транзакция.

## Описание модулей

### Модуль `stream_xbar.sv`
#### Интерфейсы

Этот модуль реализует основной функционал кроссбара, включая коммутацию данных и арбитраж. Его основные входные и выходные сигналы включают:

- **s_data_i**: Входной сигнал данных от master-устройств.
- **s_dest_i**: Сигнал, указывающий на целевое slave-устройство.
- **m_data_o**: Выходной сигнал данных на slave-устройства.
- **m_id_o**: Выходной сигнал, обозначающий номер master-устройства, чей запрос был передан на конкретное slave-устройство.

#### Функционал

- Если два master-устройства отправляют запросы на разные slave-устройства, передача данных происходит параллельно.
- Если два master-устройства отправляют запросы на одно и то же slave-устройство, модуль использует арбитраж Round-Robin для выбора master-устройства, которое будет передавать данные.

### Модуль `round_robin.sv`
#### Интерфейсы

- **Входные сигналы**:
  - `clk`: Тактовый сигнал.
  - `rst_n`: Сигнал сброса (активен низким уровнем).
  - `request_i` [NUM_REQUEST-1:0]: Запросы от master устройств.
  - `s_last_i` [NUM_REQUEST-1:0]: Флаги последнего пакета от master устройств.
- **Выходные сигналы**:
  - `grant_o` [NUM_REQUEST-1:0]: Разрешения на доступ к slave устройствам.

#### Функционал

Модуль `round_robin` реализует арбитраж с использованием политики Round-Robin для управления доступом к slave устройствам. Он генерирует разрешения на основе запросов от master устройств и текущего состояния системы, обеспечивая справедливое распределение ресурсов между запросами.

#### Внутренняя логика

1. **Подсчет пакетов**:
   - В блоке `always @(posedge clk)` отслеживается количество пакетов, поступающих от текущего master устройства. Если получен флаг последнего пакета (`s_last_i[grant_ptr]`), счетчик пакетов (`num_packet`) сбрасывается в `0`. В противном случае, счетчик увеличивается.

2. **Обновление вектора грантов**:
   - Если количество пакетов равно `0`, обновляется вектор разрешений (`grant_ptr_vec`) на основе фиксированного вектора разрешений (`grant_fixed_vec`) и указателя приоритета (`prio_ptr`).

3. **Определение приоритета**:
   - Модуль `par_coder` используется для кодирования вектора разрешений в указатель приоритета (`grant_ptr`).

4. **Обновление указателя приоритета**:
   - Указатель приоритета (`prio_ptr`) обновляется в зависимости от различных условий, таких как завершение обработки последнего пакета (`s_last_i[prio_ptr]`), окончание счетчика пакетов и состояние флага последнего пакета (`last_flag`).

5. **Фиксированное приоритизирование**:
   - Модуль `fixed_prio_arb` используется для генерации фиксированного вектора разрешений (`grant_fixed_vec`) на основе запросов, сдвинутых на указатель приоритета (`prio_ptr`).

6. **Формирование выходного сигнала**:
   - Выходной сигнал грантов (`grant_o`) формируется путем сдвига фиксированного вектора разрешений (`grant_fixed_vec`) влево на указатель приоритета (`prio_ptr`).


### Модуль `com.sv`

#### Интерфейсы

- **Входные сигналы**:
  - `req_i` [M_DATA_COUNT-1:0][S_DATA_COUNT-1:0]: Запросы от master устройств.
  - `s_data_i` [S_DATA_COUNT-1:0][T_DATA_WIDTH-1:0]: Данные от slave устройств.
  - `s_last_i` [S_DATA_COUNT-1:0]: Флаги последнего пакета от slave устройств.
  - `s_valid_i` [S_DATA_COUNT-1:0]: Флаги валидности данных от slave устройств.
- **Выходные сигналы**:
  - `m_data_o` [M_DATA_COUNT-1:0][T_DATA_WIDTH-1:0]: Данные на выходе к slave устройствам.
  - `m_id_o` [M_DATA_COUNT-1:0][T_ID_M_WIDTH-1:0]: Идентификаторы master устройств для slave.
  - `m_last_o` [M_DATA_COUNT-1:0]: Флаги последнего пакета на выходе.
  - `m_valid_o` [M_DATA_COUNT-1:0]: Флаги валидности данных на выходе.
  
#### Функционал

Модуль `com` служит для обработки данных, поступающих от нескольких master устройств и распределения их на несколько slave устройств. Он маппит запросы от master устройств на соответствующие выходы данных и идентификаторы slave устройств. Гарантируется отсутствие коллизий. Модуль определяет данные, которые должны быть переданы каждому slave, и сигнализирует о последнем пакете и валидности данных.

#### Внутренняя логика

1. **Генерация и кодирование запросов**:
   - Используются генераторы для создания экземпляров модуля `seq_coder_s`, который преобразует запросы от master устройств (`req_i`) в идентификаторы (`num_s`).

2. **Назначение выходных сигналов**:
   - `m_data_o[x]`: Содержит данные от slave, соответствующие идентификатору, полученному из `num_s[x]`.
   - `m_id_o[x]`: Идентификатор master устройства, который соответствует выходу данных.
   - `m_last_o[x]`: Флаг, указывающий на то, является ли текущий пакет последним для данного master, если данные валидны.
   - `m_valid_o[x]`: Флаг валидности данных на выходе, который установлен в `1`, если идентификатор не равен значению `S_DATA_COUNT` (представляющее собой потенциально опасное условие).

3. **Обработка и назначение сигналов**:
   - Внутри генераторов `for` итерируется по каждому slave устройству для назначения соответствующих выходных сигналов на основе входных данных и идентификаторов.

---

### Модуль `request_gen.sv`
#### Интерфейсы

- **Входные сигналы**:
  - `s_dest_i` [S_DATA_COUNT-1:0][T_DEST_WIDTH-1:0]: Целевые идентификаторы для slave устройств, отправляемые от master устройств.
  - `s_valid_i` [S_DATA_COUNT-1:0]: Флаги валидности данных от master устройств.
- **Выходные сигналы**:
  - `req_o` [M_DATA_COUNT-1:0][S_DATA_COUNT-1:0]: Запросы от master устройств к slave устройствам.

#### Функционал

Модуль `request_gen` генерирует запросы от master устройств к slave устройствам на основе целевых идентификаторов и флагов валидности. Для каждого slave устройства проверяется, соответствует ли идентификатор его целевому значению и является ли запрос валидным. Если оба условия выполнены, сигнал запроса устанавливается в `1`.

#### Внутренняя логика

1. **Генерация запросов**:
   - Используются двойные генераторы для создания запроса для каждого сочетания slave устройства (`i`) и master устройства (`j`).
   - `req_o[i][j]` устанавливается в `1`, если целевой идентификатор `s_dest_i[j]` соответствует текущему slave устройству `i` и флаг валидности `s_valid_i[j]` установлен в `1`.

2. **Сравнение и присвоение**:
   - Внутри генераторов `for` происходит сравнение целевых идентификаторов и проверка валидности, что позволяет определить, должен ли текущий master устройство отправить запрос на текущий slave.


---

### Модуль `fixed_prio_arb.sv`
Модуль генерируется скриптом на pyhton, в зависимости от поданных параметров.
#### Интерфейсы

- **Входные сигналы**:
  - `request_i` [NUM_REQUEST-1:0]: Запросы от master устройств.
- **Выходные сигналы**:
  - `grant_o` [NUM_REQUEST-1:0]: Разрешения на доступ к slave устройствам.

#### Функционал

Модуль `fixed_prio_arb` реализует простое фиксированное приоритизирование запросов. Он генерирует разрешения на доступ к slave устройствам на основе поступающих запросов от master устройств, при этом предоставляя приоритет первому запросу.

#### Внутренняя логика

1. **Формирование разрешений**:
   - Разрешение для первого запроса (`grant_o[0]`) устанавливается в `1`, если поступает запрос от первого master устройства (`request_i[0]`).
   - Разрешение для второго запроса (`grant_o[1]`) устанавливается в `1`, если поступает запрос от второго master устройства (`request_i[1]`), но только в случае, если запрос от первого master устройства не активен (`~request_i[0]`).

---

### Модуль `par_coder.sv`
Модуль генерируется скриптом на pyhton, в зависимости от поданных параметров.
#### Интерфейсы

- **Входные сигналы**:
  - `m_vec_i` [S_DATA_COUNT-1:0]: Вектор запросов от master устройств.
- **Выходные сигналы**:
  - `m_id` [T_ID_M_WIDTH-1:0]: Идентификатор активного запроса.

#### Функционал

Модуль `par_coder` кодирует вектор запросов от master устройств в идентификатор активного запроса. Он используется для определения индекса активного запроса из набора входных запросов, основываясь на приоритете запросов.

#### Внутренняя логика

1. **Определение идентификатора запроса**:
   - Если активен запрос второго устройства (`m_vec_i[1]`), то идентификатор устанавливается в `1`.
   - Если активен запрос первого устройства (`m_vec_i[0]`), то идентификатор устанавливается в `0`.
   - Если запросы активны одновременно, будет выбран идентификатор с более высоким приоритетом.
```verilog
assign m_id =   (m_vec_i[1] ?  1 : 0)
	          | (m_vec_i[0] ?  0 : 0);
```
Это выражение предполагает, что запросы в `m_vec_i` проверяются параллельно (гарантируется отсутствие коллизий), и в случае активных запросов из нескольких источников выбирается идентификатор с наибольшим приоритетом.

---

### Модуль `seq_coder_s.sv`
Модуль генерируется скриптом на pyhton, в зависимости от поданных параметров.
#### Интерфейсы

- **Входные сигналы**:
  - `m_vec_i` [S_DATA_COUNT-1:0]: Вектор запросов от master устройств.
- **Выходные сигналы**:
  - `m_id` [T_ID_M_WIDTH:0]: Идентификатор активного запроса.

#### Функционал

Модуль `seq_coder_s` кодирует вектор запросов от master устройств в идентификатор активного запроса на основе последовательного анализа. Он используется для определения индекса активного запроса из набора входных запросов с учетом заданного порядка.

#### Внутренняя логика

1. **Определение идентификатора запроса**:
   - Если активен запрос второго устройства (`m_vec_i[1]`), то идентификатор устанавливается в `0`.
   - Если активен запрос первого устройства (`m_vec_i[0]`), то идентификатор также устанавливается в `0`.
   - Если ни один запрос не активен, идентификатор устанавливается в `1`.
```verilog
assign m_id = m_vec_i[1] ?  1 :
              m_vec_i[0] ?  0 : 2;
```
Это выражение предполагает, что запросы в `m_vec_i` обрабатываются в порядке убывания их приоритета, и если ни один запрос не активен, выбирается значение по умолчанию в общем случае `S_DATA_COUNT`.

---

## Инструкция по запуску симуляции

### Шаг 1: Клонирование репозитория

Для начала работы с проектом необходимо клонировать репозиторий с GitHub:

****```bash
git clone https://github.com/BatyaPng/StreamXBar
cd StreamXBar
```
### Шаг 2: Создание конфигурации

Перед запуском симуляции необходимо задать параметры `T_DATA_WIDTH`, `S_DATA_COUNT`  и `M_DATA_COUNT` через командную строку. Это настраивается в конфигурационном скрипте `/conf/conf.py`
```bash
cd conf/
python3 conf.py T_DATA_WIDTH S_DATA_COUNT M_DATA_COUNT
```
### Шаг 3: Компиляция и запуск симуляции

Для симуляции в ModelSim необходимо вначале скомпилировать необходимые файлы. Для этого перейдём в папку `modelsim`
```bash
cd modelsim/
make
```
После чего копируем все полученный файлы в папку с проектом ModelSim


### Шаг 4: Проверка синтаксиса с использованием Verilator

Опциально можно проверить на наличие синтаксических ошибок при помощи verilator.
# Приложение
## Отчёт Quartus
![plot](https://github.com/BatyaPng/StreamXBar/blob/main/images/%D0%BE%D1%82%D1%87%D1%91%D1%82%20quartus.png?raw=true)
## Схемы
### `stream_xbar`
![plot](https://github.com/BatyaPng/StreamXBar/blob/main/images/stream_xbar_sch.png?raw=true)
### `round_robin`
![plot](https://github.com/BatyaPng/StreamXBar/blob/main/images/round_robin_sch.png?raw=true)
### `com`
![plot](https://github.com/BatyaPng/StreamXBar/blob/main/images/com_sch.png?raw=true)
### `fixed_prio_arb`
![plot](https://github.com/BatyaPng/StreamXBar/blob/main/images/fixid_prio_arb_sch.png?raw=true)