# Описание параметров
- **T_DATA_WIDTH** -- ширина пакета
- **S_DATA_COUNT** -- количество master-устройств
- **M_DATA_COUNT** -- количество slave-устройств
- **T_ID_M_WIDTH** -- ширина битового вектора, необходимая для индексации master -стройств
- **T_DEST_WIDTH** -- ширина битового вектора, необходимая для индексации slave-устройств

# Описание портов
## input logic clk
Синхросигнал
## input logic rst_n 
Активный низкий сброс
## Входные порты
### input logic [T_DATA_WIDTH-1:0] s_data_i [S_DATA_COUNT-1:0]
Данные, приходящие с master устройства. Параметр **T_DATA_WIDTH-1:0** определяет ширину пакета; **S_DATA_COUNT-1:0** индексирует массив данных, показывая, к какому master-устройству относится пакет.
### input  logic [T_DEST_WIDTH-1:0] s_dest_i [S_DATA_COUNT-1:0]
Массив, показывающий в какое slave устройство передаёт данные master. 
### input logic [S_DATA_COUNT-1:0] s_last_i
Битвый вектор, показывающей передачу последнего бита от master-устройства.
### input logic [S_DATA_COUNT-1:0] s_valid_i
Битвый вектор, показывающей запрос на передачу пакета данных от master-устройства.
### output logic [S_DATA_COUNT-1:0] s_ready_o
Битовый вектор, показывающей возможность коммутации для master-устройств.
## Выходные порты
### output logic [T_DATA_WIDTH-1:0] m_data_o [M_DATA_COUNT-1:0]
Данные, передающиеся на slave-устройства.
### output logic [T_ID_M_WIDTH-1:0] m_id_o [M_DATA_COUNT-1:0]
Массив, показывающей какое master-устройство передало данные на slave-устройство.
### output logic [M_DATA_COUNT-1:0] m_last_o
Битвый вектор, показывающей передачу последнего бита slave-устройству.
### output logic [M_DATA_COUNT-1:0] m_valid_o
Битвый вектор, показывающей запрос на передачу пакета данных slave-устройству.
### input logic [M_DATA_COUNT-1:0] m_ready_i
Битовый вектор, показывающей возможность коммутации c slave-устройством.

# Вопросы
- Когда данные считаются переданными?
- Как два m могут указывать на один s? 
```
([T_DEST_WIDTH-1:0] s_dest_i [S_DATA_COUNT-1:0] )
```
В данном массиве **"x" индексирует s устройство, а "y" -- m устройство**. Таким образом два m указывают на один s когда есть **полное совпадение битов разных "y"**. 
- Что такое тразнакция и что такое пакет?
Транзакция -- событие, при котором m передаёт данные s. Наступает при одновременно  равных единце сигналах valid и ready
Пакет -- количество данных, передаваемых от m к s за один такт. Измеряется в битах
- Как детектить коллизии?
# План работы
1. Нарисовать схему коммутатора
2. Написать или найти необходимый round robin 
3. Написать verilog
4. Написать test bench

# Мысли
Условие пересылки в отсутвие коллизий: s_valid_i[i] * m_ready_i[i] == 1 

Необходимо создать conflict_resolver, который будет разрешать возможные коллизии по доступу к slay-устройствам. В свою очередь данный блок состоит из блока обнаружения коллизий, rb для каждого slay-устройства и конечного мультиплексора, который выбирает какие данные брать

На выходе из cf будет вектор конфликтов длинной в s и массив векторов ширной m глубиной s

Перед выходом из cr будет мультиплексор на управляющий вход каторого подаётся i значения вектора кофликтов, а на входы данные с m и данные с rb

Я не понимаю, как мне обеспечить приоритет: по условию задания необходимо реализовать roundrobin, который работыт транзакиционно, то есть приоритет передётся после завершения транзакции.
# Com block
Сперва смотрим на s_valid_i[i]. Если единица, то обращается к s_dest_i[i], после чего обращется к m_ready_i[s_dest_i[i]] если единица, то начинается транзакция. Работает с инвариантом, что отсутсвуют коллизии. Схема одна для всех m и s.
# Conf res
На выходе из conf res вектор [S_DATA_COUNT-1:0] s_valid_noconf на вход [T_DEST_WIDTH-1:0] s_dest_i [S_DATA_COUNT-1:0] вектор для конкретного s. Таким образом
# Round Robin
Изменение prio_ptr будет происходит следующим образом:
начальное значение ноль. Следующее gnt_ptr. После этого проверятеся , не было ли передано последнего бита, если да, то gnt_ptr++
Входные сигналы: clk, rst_n, req_vec, s_last_i
Выходные сигналы: 


# План работы схемы
1. Сигналы
    [T_DEST_WIDTH-1:0]  s_dest_i [S_DATA_COUNT-1:0],
	[S_DATA_COUNT-1:0] s_last_i ,
	[S_DATA_COUNT-1:0] s_valid_i,
	подаются на вход блока conf_resolver
2. Сигналы
    [T_DEST_WIDTH-1:0]  s_dest_i [S_DATA_COUNT-1:0],
	[S_DATA_COUNT-1:0] s_valid_i,
	подаются на вход блока request_gen
3. Внутри блока request gen сигнгал если s_valid_i[i] == 1, то arr_req[s_dest_i[i]][i] == 1 
4. Сигнал arr_req[s_dest_i[i]] подаётся на i-ый блок round_robin
5. Внутри блока round_robin начальное значение gnt_ptr ноль. Следующее gnt_ptr определяеся по стат. арбитру. После этого проверятеся , не было ли передано последнего бита, если да, то gnt_ptr++.
6. Сигналы из round_robin скалдываются и выводят из блока вектор conf_resolver s_valid_noconf.